(setf NoL 10)
(setf mainBoard (make-array (list NoL NoL)))
(setf bip #\â”¼)
(defun initializeBoard ()
  (do ((i 0 (1+ i)))
      ((= i NoL) nil)
      (do ((j 0 (1+ j)))
	  ((= j NoL) nil)
	  (setf (aref mainBoard i j) bip))))
(initializeBoard)
(defun drawBoard (bo)
  (format t " 0123456789~%")
  (do ((i 0 (1+ i)))
      ((= i NoL) nil)
      (format t "~D" i)
      (do ((j 0 (1+ j)))
	  ((= j NoL) nil)
	  (format t "~A" (aref bo j i)))
      (format t "~D~%" i))
  (format t " 0123456789~%"))
(defun getPlayerColor ()
  (let ((r nil))
    (loop
     (if r (return r))
     (format t "Do you want to be O or X?~%")
     (setf r (read))
     (if (or (eq r 'O) (eq r 'X))
	 (format t "You will be ~A~%" r)
       (progn
	 (format t "Ask agian: ")
	 (setf r nil))))))
(setf *random-state* (make-random-state t))
(defun getStartingPlayer ()
  (if (= (random 2) 0)
      'computer
    'player))
(defun playAgain ()
  (format t "Do you want to play again? (yes or no)~%")
  (if (eq (read) 'yes)
      t
    nil))
(defun makeMove (bo color move)
  (setf (aref bo (car move) (cdr move)) color))
(defun isWinner (bo color)
  (let (nc)
    (if (eq color 'O)
	(setf nc 'X)
      (setf nc 'O))
    (do ((i 0 (1+ i)))
	((= i NoL) nil)
	(do ((j 0 (1+ j)))
	    ((= j NoL) nil)
	    (cond
	     ((and (< j (- NoL 4))
		   (eq (aref bo i j) (aref bo i (+ j 1)))
		   (eq (aref bo i j) (aref bo i (+ j 2)))
		   (eq (aref bo i j) (aref bo i (+ j 3)))
		   (eq (aref bo i j) (aref bo i (+ j 4)))
		   (eq (aref bo i j) color)
		   (or (and (< j (- NoL 5))
			    (eq (aref bo i (+ j 5)) bip))
		       (= (+ j 5) NoL)))
	      (return-from isWinner t))
	     ((and (< i (- NoL 4))
		   (eq (aref bo i j) (aref bo (+ i 1) j))
		   (eq (aref bo i j) (aref bo (+ i 2) j))
		   (eq (aref bo i j) (aref bo (+ i 3) j))
		   (eq (aref bo i j) (aref bo (+ i 4) j))
		   (eq (aref bo i j) color))
	      (return-from isWinner t))
	     ((and (and (< i (- NoL 4)) (< j (- NoL 4)))
		   (eq (aref bo i j) (aref bo (+ i 1) (+ j 1)))
		   (eq (aref bo i j) (aref bo (+ i 2) (+ j 2)))
		   (eq (aref bo i j) (aref bo (+ i 3) (+ j 3)))
		   (eq (aref bo i j) (aref bo (+ i 4) (+ j 4)))
		   (eq (aref bo i j) color))
	      (return-from isWinner t))
	     ((and (and (< 3 i) (< 3 j))
		   (eq (aref bo i j) (aref bo (- i 1) (- j 1)))
		   (eq (aref bo i j) (aref bo (- i 2) (- j 2)))
		   (eq (aref bo i j) (aref bo (- i 3) (- j 3)))
		   (eq (aref bo i j) (aref bo (- i 4) (- j 4)))
		   (eq (aref bo i j) color))
	      (return-from isWinner t))
	     ((and (and (< 3 i) (< j (- NoL 4)))
		   (eq (aref bo i j) (aref bo (- i 1) (+ j 1)))
		   (eq (aref bo i j) (aref bo (- i 2) (+ j 2)))
		   (eq (aref bo i j) (aref bo (- i 3) (+ j 3)))
		   (eq (aref bo i j) (aref bo (- i 4) (+ j 4)))
		   (eq (aref bo i j) color))
	      (return-from isWinner t))
	     ((and (and (< 3 j) (< i (- NoL 4)))
		   (eq (aref bo i j) (aref bo (+ i 1) (- j 1)))
		   (eq (aref bo i j) (aref bo (+ i 2) (- j 2)))
		   (eq (aref bo i j) (aref bo (+ i 3) (- j 3)))
		   (eq (aref bo i j) (aref bo (+ i 4) (- j 4)))
		   (eq (aref bo i j) color))
	      (return-from isWinner t))
	     (t nil))))))
(defun isMaybeWinner (bo color)
  (do ((i 0 (1+ i)))
      ((= i NoL) nil)
      (do ((j 0 (1+ j)))
	  ((= j NoL) nil)
	  (cond
	   ((and (< j (- NoL 4))
		 (eq (aref bo i j) (aref bo i (+ j 1)))
		 (eq (aref bo i j) (aref bo i (+ j 2)))
		 (eq (aref bo i j) (aref bo i (+ j 3)))
		 (eq (aref bo i j) color)
		 (or (and (< j (- NoL 5))
			  (eq (aref bo i (+ j 5)) bip))
		     (= (+ j 5) NoL)))
	    (return-from isMaybeWinner t))
	   ((and (< i (- NoL 4))
		 (eq (aref bo i j) (aref bo (+ i 1) j))
		 (eq (aref bo i j) (aref bo (+ i 2) j))
		 (eq (aref bo i j) (aref bo (+ i 3) j))
		 (eq (aref bo i j) color))
	    (return-from isMaybeWinner t))
	   ((and (and (< i (- NoL 4)) (< j (- NoL 4)))
		 (eq (aref bo i j) (aref bo (+ i 1) (+ j 1)))
		 (eq (aref bo i j) (aref bo (+ i 2) (+ j 2)))
		 (eq (aref bo i j) (aref bo (+ i 3) (+ j 3)))
		 (eq (aref bo i j) color))
	    (return-from isMaybeWinner t))
	   ((and (and (< 3 i) (< 3 j))
		 (eq (aref bo i j) (aref bo (- i 1) (- j 1)))
		 (eq (aref bo i j) (aref bo (- i 2) (- j 2)))
		 (eq (aref bo i j) (aref bo (- i 3) (- j 3)))
		 (eq (aref bo i j) color))
	    (return-from isMaybeWinner t))
	   ((and (and (< 2 i) (< j (- NoL 4)))
		 (eq (aref bo i j) (aref bo (- i 1) (+ j 1)))
		 (eq (aref bo i j) (aref bo (- i 2) (+ j 2)))
		 (eq (aref bo i j) (aref bo (- i 3) (+ j 3)))
		 (eq (aref bo i j) color))
	    (return-from isMaybeWinner t))
	   ((and (and (< 3 j) (< i (- NoL 4)))
		 (eq (aref bo i j) (aref bo (+ i 1) (- j 1)))
		 (eq (aref bo i j) (aref bo (+ i 2) (- j 2)))
		 (eq (aref bo i j) (aref bo (+ i 3) (- j 3)))
		 (eq (aref bo i j) color))
	    (return-from isMaybeWinner t))
	   (t nil)))))
(defun getBoardCopy (bo)
  (let ((dupeBoard (make-array (list NoL NoL))))
    (do ((i 0 (1+ i)))
	((= i NoL) dupeBoard)
	(do ((j 0 (1+ j)))
	    ((= j NoL) nil)
	    (setf (aref dupeBoard i j) (aref bo i j))))))
(defun isSpaceFree (bo move)
  (if (eq (aref bo (car move) (cdr move)) bip)
      t
    nil))
(defun getPlayerMove (bo)
  (let ((r nil))
    (loop
     (if r (return r))
     (format t "What is your next move?~%(For example, input (9 . 0) to move to top right corner.~%")
     (setf r (read))
     (if (and (consp r) (isSpaceFree bo r))
	 (format t "You moved to ~A~%" r)
       (progn
	 (format t "Ask again: ")
	 (setf r nil))))))
(defun getComputerMove (bo comcol)
  (let (playercol (move nil))
    (if (eq comcol 'x)
	(setf playercol 'O)
      (setf playercol 'X))
    (loop
     (if move (return move))
     (do ((i 0 (1+ i)))
	 ((= i NoL) move)
	 (do ((j 0 (1+ j)))
	     ((= j NoL) move)
	     (let ((copy (getBoardCopy bo)))
	       (cond
		((isSpaceFree copy (cons i j))
		 (makeMove copy comcol (cons i j))
		 (if (isWinner copy comcol)
		     (progn
		       (setf move (cons i j))
		       (return-from getComputerMove move))))))))
     (do ((i 0 (1+ i)))
	 ((= i NoL) move)
	 (do ((j 0 (1+ j)))
	     ((= j NoL) move)
	     (let ((copy (getBoardCopy bo)))
	       (cond
		((isSpaceFree copy (cons i j))
		 (makeMove copy playercol (cons i j))
		 (if (isWinner copy playercol)
		     (progn
		       (setf move (cons i j))
		       (return-from getComputerMove move))))))))
     (do ((i 0 (1+ i)))
	 ((= i NoL) move)
	 (do ((j 0 (1+ j)))
	     ((= j NoL) move)
	     (let ((copy (getBoardCopy bo)))
	       (cond
		((isSpaceFree copy (cons i j))
		 (makeMove copy playercol (cons i j))
		 (if (isMaybeWinner copy playercol)
		     (progn
		       (setf move (cons i j))
		       (return-from getComputerMove move))))))))
     (if (isSpaceFree mainBoard (cons 5 5))
	 (setf move (cons 5 5)))
     (loop
      (if move (return move))
      (let (x y)
	(setf x (+ 4 (random 3)))
	(setf y (+ 4 (random 3)))
	(if (isSpaceFree bo (cons x y))
	    (setf move (cons x y)))))
     (loop
      (if move (return move))
      (let (x y)
	(setf x (+ 3 (random 5)))
	(setf y (+ 3 (random 5)))
	(if (isSpaceFree bo (cons x y))
	    (setf move (cons x y)))))
     (loop
      (if move (return move))
      (let (x y)
	(setf x (random NoL))
	(setf y (random NoL))
	(if (isSpaceFree bo (cons x y))
	    (setf move (cons x y))))))))
(defun isBoardFull (board)
  (do ((i 0 (1+ i)))
      ((= i NoL) t)
      (do ((j 0 (1+ j)))
	  ((= j NoL) nil)
	  (if (isSpaceFree board (cons i j))
	      (return-from isBoardFull nil)))))
(format t "Welcome to Omok!~%")
(loop
 (if nil (return))
 (initializeBoard)
 (setf PC (getPlayerColor))
 (if (eq PC 'O)
     (setf CC 'X)
   (setf CC 'O))
 (setf turn (getStartingPlayer))
 (format t "The ~A will go first.~%" turn)
 (setf gameIsPlaying t)
 (loop
  (if (null gameIsPlaying) (return))
  (cond
   ((eq turn 'player)
    (drawBoard mainBoard)
    (let ((move (getPlayerMove mainBoard)))
      (makeMove mainBoard PC move)
      (cond
       ((isWinner mainBoard PC)
	(drawBoard mainBoard)
	(format t "You have won the game!~%")
	(setf gameIsPlaying nil))
       ((isBoardFull mainBoard)
	(drawBoard mainBoard)
	(format t "The game is a tie!~%")
	(setf gameIsPlaying nil))
       (t
	(setf turn 'computer)))))
   (t
    (let ((move (getComputerMove mainBoard CC)))
      (makeMove mainBoard CC move)
      (cond
       ((isWinner mainBoard CC)
	(drawBoard mainBoard)
	(format t "The computer has beaten you! You lose.~%")
	(setf gameIsPlaying nil))
       ((isBoardFull mainBoard)
	(drawBoard mainBoard)
	(format t "The game is a tie!~%")
	(setf gameIsPlaying nil))
       (t
	(setf turn 'player)))))))
 (if (playAgain)
     nil
   (return nil)))
